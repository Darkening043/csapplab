# bomb 实验分析

## 1. 简介

这个实验要求用逆向技术破解`./bomb`中的6个字符串。  
基本思路就是使用`gdb`反汇编对应源文件中的字符串处理函数，然后找出对应的字符串。  
由于有`bomb.c`的帮助，我们可以很简单地确定函数的地址，这降低了不少难度。  
废话少说，让我们开始吧！
> 作为辅助，我写了一个小程序，用于将gdb中十六进制表示的字节机器码转化为一串ascii码并打印出来

## 2. `bomb`

### **Phase 1**

使用gdb反汇编函数`phase_1()`得到如下汇编代码：
```x86asm
0x0000000000400ee0 <+0>:     sub    $0x8,%rsp
0x0000000000400ee4 <+4>:     mov    $0x402400,%esi
0x0000000000400ee9 <+9>:     callq  0x401338 <strings_not_equal>
0x0000000000400eee <+14>:    test   %eax,%eax
0x0000000000400ef0 <+16>:    je     0x400ef7 <phase_1+23>
0x0000000000400ef2 <+18>:    callq  0x40143a <explode_bomb>
0x0000000000400ef7 <+23>:    add    $0x8,%rsp
0x0000000000400efb <+27>:    retq
```
稍加观察，看到调用`<strings_not_equal>`前有一次参数赋值`mov $0x402400, %esi`  
于是猜测`0x402400`是字符串的地址，利用gdb查看`0x402400`处的字节表示。
```
(gdb) x /55xb 0x402400
0x402400:       0x42    0x6f    0x72    0x64    0x65    0x72    0x20    0x72
0x402408:       0x65    0x6c    0x61    0x74    0x69    0x6f    0x6e    0x73
0x402410:       0x20    0x77    0x69    0x74    0x68    0x20    0x43    0x61
0x402418:       0x6e    0x61    0x64    0x61    0x20    0x68    0x61    0x76
0x402420:       0x65    0x20    0x6e    0x65    0x76    0x65    0x72    0x20
0x402428:       0x62    0x65    0x65    0x6e    0x20    0x62    0x65    0x74
0x402430:       0x74    0x65    0x72    0x2e    0x00    0x00    0x00
```
将这段机器码使用`ascii`转化为ascii码，得到：  
`Border relations with Canada have never been better.`


### **Phase_2**
`phase_2()`反汇编得到：
```x86asm
0x0000000000400efc <+0>:     push   %rbp
0x0000000000400efd <+1>:     push   %rbx
0x0000000000400efe <+2>:     sub    $0x28,%rsp      //初始化了一个数组
0x0000000000400f02 <+6>:     mov    %rsp,%rsi       //将这个数组的地址作为参数传递给<read_six_numbers>
0x0000000000400f05 <+9>:     callq  0x40145c <read_six_numbers>
0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp)
0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>
0x0000000000400f10 <+20>:    callq  0x40143a <explode_bomb>
0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>
0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax
0x0000000000400f1a <+30>:    add    %eax,%eax
0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)
0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>
0x0000000000400f20 <+36>:    callq  0x40143a <explode_bomb>
0x0000000000400f25 <+41>:    add    $0x4,%rbx
0x0000000000400f29 <+45>:    cmp    %rbp,%rbx
0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>
0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx
0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp
0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>
0x0000000000400f3c <+64>:    add    $0x28,%rsp
0x0000000000400f40 <+68>:    pop    %rbx
0x0000000000400f41 <+69>:    pop    %rbp
0x0000000000400f42 <+70>:    retq  
```
其中，看到一个函数`read_six_numbers()`，为了搞清楚这个函数干了什么，将其反汇编：
```x86asm
0x000000000040145c <+0>:     sub    $0x18,%rsp
0x0000000000401460 <+4>:     mov    %rsi,%rdx
0x0000000000401463 <+7>:     lea    0x4(%rsi),%rcx
0x0000000000401467 <+11>:    lea    0x14(%rsi),%rax
0x000000000040146b <+15>:    mov    %rax,0x8(%rsp)
0x0000000000401470 <+20>:    lea    0x10(%rsi),%rax
0x0000000000401474 <+24>:    mov    %rax,(%rsp)
0x0000000000401478 <+28>:    lea    0xc(%rsi),%r9
0x000000000040147c <+32>:    lea    0x8(%rsi),%r8
0x0000000000401480 <+36>:    mov    $0x4025c3,%esi
0x0000000000401485 <+41>:    mov    $0x0,%eax
0x000000000040148a <+46>:    callq  0x400bf0 <__isoc99_sscanf@plt>
0x000000000040148f <+51>:    cmp    $0x5,%eax
0x0000000000401492 <+54>:    jg     0x401499 <read_six_numbers+61>
0x0000000000401494 <+56>:    callq  0x40143a <explode_bomb>
0x0000000000401499 <+61>:    add    $0x18,%rsp
0x000000000040149d <+65>:    retq 
```
可以看到，函数中有一个很重要的调用`sscanf()`  

关于`sscanf()`：

> `int sscanf(const char *str, const char *format, ...)`  
> 与`scanf()`以`stdin`为源不同，`sscanf()`以一个字符串为源  
> 例如：
> ```C
> #include <stdio.h>
>#include <string.h>
>#include <stdlib.h>
>
>int main()
>{
>   int day, year;
>   char weekday[20], month[20], dtm[100];
>
>   strcpy( dtm, "Saturday March 25 1989" );
>   sscanf( dtm, "%s %s %d  %d", weekday, month, &day, &year );
>
>   printf("%s %d, %d = %s\n", month, day, year, weekday );
>    
>   return(0);
>}
> ```
> 上述函数产生输出：`March 25, 1989 = Saturday`

综合以上信息，可以看出，`read_six_numbers()`做的事很简单，就是从`0x4025c3`处的字符串中读入了6个`int`。  
通过`ascii`将`0x4025c3`处的字符串翻译为`ascii`码得到：`%d %d %d %d %d %d`， 这是`sscanf()`使用的格式字符串。  
因此，我们的输入字符串的格式应该是：  
`%d %d %d %d %d %d...`：六个数字，后跟任意的字符串  

再通过`phase_2`分析，不难发现，这六个数字是以1为初始值，2为倍数增长的等比数列。因此，输入字符串应该是：  
`1 2 4 8 16 32[...]`

### **phase 3**
将`phase_3()`反汇编：
```x86asm
0x0000000000400f43 <+0>:     sub    $0x18,%rsp
0x0000000000400f47 <+4>:     lea    0xc(%rsp),%rcx
0x0000000000400f4c <+9>:     lea    0x8(%rsp),%rdx
0x0000000000400f51 <+14>:    mov    $0x4025cf,%esi
0x0000000000400f56 <+19>:    mov    $0x0,%eax
0x0000000000400f5b <+24>:    callq  0x400bf0 <__isoc99_sscanf@plt>
0x0000000000400f60 <+29>:    cmp    $0x1,%eax
0x0000000000400f63 <+32>:    jg     0x400f6a <phase_3+39>
0x0000000000400f65 <+34>:    callq  0x40143a <explode_bomb>
0x0000000000400f6a <+39>:    cmpl   $0x7,0x8(%rsp)
0x0000000000400f6f <+44>:    ja     0x400fad <phase_3+106>
0x0000000000400f71 <+46>:    mov    0x8(%rsp),%eax
0x0000000000400f75 <+50>:    jmpq   *0x402470(,%rax,8)
0x0000000000400f7c <+57>:    mov    $0xcf,%eax
0x0000000000400f81 <+62>:    jmp    0x400fbe <phase_3+123>
0x0000000000400f83 <+64>:    mov    $0x2c3,%eax
0x0000000000400f88 <+69>:    jmp    0x400fbe <phase_3+123>
0x0000000000400f8a <+71>:    mov    $0x100,%eax
0x0000000000400f8f <+76>:    jmp    0x400fbe <phase_3+123>
0x0000000000400f91 <+78>:    mov    $0x185,%eax
0x0000000000400f96 <+83>:    jmp    0x400fbe <phase_3+123>
0x0000000000400f98 <+85>:    mov    $0xce,%eax
0x0000000000400f9d <+90>:    jmp    0x400fbe <phase_3+123>
0x0000000000400f9f <+92>:    mov    $0x2aa,%eax
0x0000000000400fa4 <+97>:    jmp    0x400fbe <phase_3+123>
0x0000000000400fa6 <+99>:    mov    $0x147,%eax
0x0000000000400fab <+104>:   jmp    0x400fbe <phase_3+123>
0x0000000000400fad <+106>:   callq  0x40143a <explode_bomb>
0x0000000000400fb2 <+111>:   mov    $0x0,%eax
0x0000000000400fb7 <+116>:   jmp    0x400fbe <phase_3+123>
0x0000000000400fb9 <+118>:   mov    $0x137,%eax
0x0000000000400fbe <+123>:   cmp    0xc(%rsp),%eax
0x0000000000400fc2 <+127>:   je     0x400fc9 <phase_3+134>
0x0000000000400fc4 <+129>:   callq  0x40143a <explode_bomb>
0x0000000000400fc9 <+134>:   add    $0x18,%rsp
0x0000000000400fcd <+138>:   retq
```
从`0x0000000000400f75 <+50>:    jmpq   *0x402470(,%rax,8)`可以看出，这里使用了跳转表的结构，即原C语言函数是一个`switch`的结构。我们从这里入手分析这段程序。  
下面是跳转表储存的地址列表：
```x86asm
(gdb) x /60xb 0x402470
0x402470:       0x7c    0x0f    0x40    0x00    0x00    0x00    0x00    0x00
0x402478:       0xb9    0x0f    0x40    0x00    0x00    0x00    0x00    0x00
0x402480:       0x83    0x0f    0x40    0x00    0x00    0x00    0x00    0x00
0x402488:       0x8a    0x0f    0x40    0x00    0x00    0x00    0x00    0x00
0x402490:       0x91    0x0f    0x40    0x00    0x00    0x00    0x00    0x00
0x402498:       0x98    0x0f    0x40    0x00    0x00    0x00    0x00    0x00
0x4024a0:       0x9f    0x0f    0x40    0x00    0x00    0x00    0x00    0x00
0x4024a8:       0xa6    0x0f    0x40    0x0
```
综合上述信息分析：`phase_3()`将前缀为2个整数的字符串读入，检验2个前缀整数是否符合`switch`所定义的关系。经过分析，总共有6中可能字符串模式：
```
2 707 [random string]
3 256 [random string]
4 389 [random string]
5 206 [random string]
6 682 [random string]
7 327 [random string]
```

### **phase 4**

```x86asm
0x000000000040100c <+0>:     sub    $0x18,%rsp
0x0000000000401010 <+4>:     lea    0xc(%rsp),%rcx
0x0000000000401015 <+9>:     lea    0x8(%rsp),%rdx
0x000000000040101a <+14>:    mov    $0x4025cf,%esi
0x000000000040101f <+19>:    mov    $0x0,%eax
0x0000000000401024 <+24>:    callq  0x400bf0 <__isoc99_sscanf@plt>
0x0000000000401029 <+29>:    cmp    $0x2,%eax
0x000000000040102c <+32>:    jne    0x401035 <phase_4+41>
0x000000000040102e <+34>:    cmpl   $0xe,0x8(%rsp)
0x0000000000401033 <+39>:    jbe    0x40103a <phase_4+46>
0x0000000000401035 <+41>:    callq  0x40143a <explode_bomb>
0x000000000040103a <+46>:    mov    $0xe,%edx
0x000000000040103f <+51>:    mov    $0x0,%esi
0x0000000000401044 <+56>:    mov    0x8(%rsp),%edi
0x0000000000401048 <+60>:    callq  0x400fce <func4>
0x000000000040104d <+65>:    test   %eax,%eax
0x000000000040104f <+67>:    jne    0x401058 <phase_4+76>
0x0000000000401051 <+69>:    cmpl   $0x0,0xc(%rsp)
0x0000000000401056 <+74>:    je     0x40105d <phase_4+81>
0x0000000000401058 <+76>:    callq  0x40143a <explode_bomb>
0x000000000040105d <+81>:    add    $0x18,%rsp
0x0000000000401061 <+85>:    retq 
```

```C
int fun4(int x, int y, int z)
{
    int t=(z-y)>>31+(z-y)>>1+y;
    if(t<=x){
        if(t==x){
            return 0;
        }else{
            return 2*fun4(x, t+1, z)+1;
        }
    }else{
        return 2*fun4(x, y, t-1);
    }
}
void phase_4(char *input)
{
    int x[2];
    int y;
    if(sscanf(input, " %d %d", &x[0], &x[1])!=2){
        explode_bomb();
    }else{
        if(x[0]<=14){
            y=fun4(x[0], 0, 14);
        }else{
            explode_bomb();
        }
        if(y!=0 || x[1]!=0){
            explode_bomb();
        }
    }
}
```
由上述逆向代码，这个字符串同样也是一个前缀整数字符串，只有当字符串前缀整数满足以下两个条件时，炸弹不会爆炸：  
1. `fun4(x[0], 0, 14)==0`, 即`x[0]=0`
2. `x[1]=0`

因此，字符串模式为：  
`0 7 [random string]`

### **phase_5**

`phase_5`反汇编代码：
```x86asm
0x0000000000401062 <+0>:     push   %rbx
0x0000000000401063 <+1>:     sub    $0x20,%rsp
0x0000000000401067 <+5>:     mov    %rdi,%rbx
0x000000000040106a <+8>:     mov    %fs:0x28,%rax
0x0000000000401073 <+17>:    mov    %rax,0x18(%rsp)
0x0000000000401078 <+22>:    xor    %eax,%eax
0x000000000040107a <+24>:    callq  0x40131b <string_length>
0x000000000040107f <+29>:    cmp    $0x6,%eax
0x0000000000401082 <+32>:    je     0x4010d2 <phase_5+112>
0x0000000000401084 <+34>:    callq  0x40143a <explode_bomb>
0x0000000000401089 <+39>:    jmp    0x4010d2 <phase_5+112>
0x000000000040108b <+41>:    movzbl (%rbx,%rax,1),%ecx
0x000000000040108f <+45>:    mov    %cl,(%rsp)
0x0000000000401092 <+48>:    mov    (%rsp),%rdx
0x0000000000401096 <+52>:    and    $0xf,%edx
0x0000000000401099 <+55>:    movzbl 0x4024b0(%rdx),%edx
0x00000000004010a0 <+62>:    mov    %dl,0x10(%rsp,%rax,1)
0x00000000004010a4 <+66>:    add    $0x1,%rax
0x00000000004010a8 <+70>:    cmp    $0x6,%rax
0x00000000004010ac <+74>:    jne    0x40108b <phase_5+41>
0x00000000004010ae <+76>:    movb   $0x0,0x16(%rsp)
0x00000000004010b3 <+81>:    mov    $0x40245e,%esi
0x00000000004010b8 <+86>:    lea    0x10(%rsp),%rdi
0x00000000004010bd <+91>:    callq  0x401338 <strings_not_equal>
0x00000000004010c2 <+96>:    test   %eax,%eax
0x00000000004010c4 <+98>:    je     0x4010d9 <phase_5+119>
0x00000000004010c6 <+100>:   callq  0x40143a <explode_bomb>
0x00000000004010cb <+105>:   nopl   0x0(%rax,%rax,1)
0x00000000004010d0 <+110>:   jmp    0x4010d9 <phase_5+119>
0x00000000004010d2 <+112>:   mov    $0x0,%eax
0x00000000004010d7 <+117>:   jmp    0x40108b <phase_5+41>
0x00000000004010d9 <+119>:   mov    0x18(%rsp),%rax
0x00000000004010de <+124>:   xor    %fs:0x28,%rax
0x00000000004010e7 <+133>:   je     0x4010ee <phase_5+140>
0x00000000004010e9 <+135>:   callq  0x400b30 <__stack_chk_fail@plt>
0x00000000004010ee <+140>:   add    $0x20,%rsp
0x00000000004010f2 <+144>:   pop    %rbx
0x00000000004010f3 <+145>:   retq
```
经过分析可以看出，`phase_5()`做以下几件事情：
1. 读入输入字符串的前6个字符
2. 将字符数组映射为另一个字符数组
3. 将此字符数组与设置好的字符数组(称其为标准字符串)比较，若相等，则通过

- 预先设置好的字符数组存放在`0x40245e`处：  
    ```
    0x40245e:       0x66    0x6c    0x79    0x65    0x72    0x73    0x00
    // 翻译为flyers
    ```

- 映射关系为：
    ```
    y=*(0x4024b0+x%0x10)
    // 其中，x为输入字符串的字符，y是映射后的字符串
    ```

通过自己写的小程序`check`找出`flyers`中每个字符相对于`0x4024b0`的偏移地址:
```bash
$ ./ascii | ./check 
e:0x5
r:0x6
s:0x7
f:0x9
y:0xe
l:0xf
```
现在我们只需要将这几个对应的偏移地址按照标准字符串的顺序，加上`0x1`的整数倍，就得到我们的输入字符串：
`0xk9 0xkf 0xke 0xk5 0xk6 0xk7`

取`k=3`，最终得到字符串模式：(注意，末尾须跟上一个空格)
```
9?>567 
```

### **phase 6**
```x86asm
0x00000000004010f4 <+0>:     push   %r14
0x00000000004010f6 <+2>:     push   %r13
0x00000000004010f8 <+4>:     push   %r12
0x00000000004010fa <+6>:     push   %rbp
0x00000000004010fb <+7>:     push   %rbx
0x00000000004010fc <+8>:     sub    $0x50,%rsp
0x0000000000401100 <+12>:    mov    %rsp,%r13
0x0000000000401103 <+15>:    mov    %rsp,%rsi
0x0000000000401106 <+18>:    callq  0x40145c <read_six_numbers>
0x000000000040110b <+23>:    mov    %rsp,%r14
0x000000000040110e <+26>:    mov    $0x0,%r12d
--------------------------------------------------------------
0x0000000000401114 <+32>:    mov    %r13,%rbp
0x0000000000401117 <+35>:    mov    0x0(%r13),%eax
0x000000000040111b <+39>:    sub    $0x1,%eax
0x000000000040111e <+42>:    cmp    $0x5,%eax
0x0000000000401121 <+45>:    jbe    0x401128 <phase_6+52>
0x0000000000401123 <+47>:    callq  0x40143a <explode_bomb>
0x0000000000401128 <+52>:    add    $0x1,%r12d
0x000000000040112c <+56>:    cmp    $0x6,%r12d
0x0000000000401130 <+60>:    je     0x401153 <phase_6+95>
0x0000000000401132 <+62>:    mov    %r12d,%ebx
0x0000000000401135 <+65>:    movslq %ebx,%rax
0x0000000000401138 <+68>:    mov    (%rsp,%rax,4),%eax
0x000000000040113b <+71>:    cmp    %eax,0x0(%rbp)
0x000000000040113e <+74>:    jne    0x401145 <phase_6+81>
0x0000000000401140 <+76>:    callq  0x40143a <explode_bomb>
0x0000000000401145 <+81>:    add    $0x1,%ebx
0x0000000000401148 <+84>:    cmp    $0x5,%ebx
0x000000000040114b <+87>:    jle    0x401135 <phase_6+65>
0x000000000040114d <+89>:    add    $0x4,%r13
0x0000000000401151 <+93>:    jmp    0x401114 <phase_6+32>
------------------------------------------------------------
0x0000000000401153 <+95>:    lea    0x18(%rsp),%rsi
0x0000000000401158 <+100>:   mov    %r14,%rax
0x000000000040115b <+103>:   mov    $0x7,%ecx
0x0000000000401160 <+108>:   mov    %ecx,%edx
0x0000000000401162 <+110>:   sub    (%rax),%edx
0x0000000000401164 <+112>:   mov    %edx,(%rax)
0x0000000000401166 <+114>:   add    $0x4,%rax
0x000000000040116a <+118>:   cmp    %rsi,%rax
0x000000000040116d <+121>:   jne    0x401160 <phase_6+108>
------------------------------------------------------------
0x000000000040116f <+123>:   mov    $0x0,%esi
0x0000000000401174 <+128>:   jmp    0x401197 <phase_6+163>
0x0000000000401176 <+130>:   mov    0x8(%rdx),%rdx
0x000000000040117a <+134>:   add    $0x1,%eax
0x000000000040117d <+137>:   cmp    %ecx,%eax
0x000000000040117f <+139>:   jne    0x401176 <phase_6+130>
0x0000000000401181 <+141>:   jmp    0x401188 <phase_6+148>
----------------------------------------------------------
0x0000000000401183 <+143>:   mov    $0x6032d0,%edx
0x0000000000401188 <+148>:   mov    %rdx,0x20(%rsp,%rsi,2)
0x000000000040118d <+153>:   add    $0x4,%rsi
0x0000000000401191 <+157>:   cmp    $0x18,%rsi
0x0000000000401195 <+161>:   je     0x4011ab <phase_6+183>
0x0000000000401197 <+163>:   mov    (%rsp,%rsi,1),%ecx
0x000000000040119a <+166>:   cmp    $0x1,%ecx
0x000000000040119d <+169>:   jle    0x401183 <phase_6+143>
---------------------------------------------------------
0x000000000040119f <+171>:   mov    $0x1,%eax
0x00000000004011a4 <+176>:   mov    $0x6032d0,%edx
0x00000000004011a9 <+181>:   jmp    0x401176 <phase_6+130>
0x00000000004011ab <+183>:   mov    0x20(%rsp),%rbx
0x00000000004011b0 <+188>:   lea    0x28(%rsp),%rax
0x00000000004011b5 <+193>:   lea    0x50(%rsp),%rsi
0x00000000004011ba <+198>:   mov    %rbx,%rcx
0x00000000004011bd <+201>:   mov    (%rax),%rdx
0x00000000004011c0 <+204>:   mov    %rdx,0x8(%rcx)
0x00000000004011c4 <+208>:   add    $0x8,%rax
0x00000000004011c8 <+212>:   cmp    %rsi,%rax
0x00000000004011cb <+215>:   je     0x4011d2 <phase_6+222>
0x00000000004011cd <+217>:   mov    %rdx,%rcx
0x00000000004011d0 <+220>:   jmp    0x4011bd <phase_6+201>
--------------------------------------------------------
0x00000000004011d2 <+222>:   movq   $0x0,0x8(%rdx)
0x00000000004011da <+230>:   mov    $0x5,%ebp
0x00000000004011df <+235>:   mov    0x8(%rbx),%rax
0x00000000004011e3 <+239>:   mov    (%rax),%eax
0x00000000004011e5 <+241>:   cmp    %eax,(%rbx)
0x00000000004011e7 <+243>:   jge    0x4011ee <phase_6+250>
0x00000000004011e9 <+245>:   callq  0x40143a <explode_bomb>
0x00000000004011ee <+250>:   mov    0x8(%rbx),%rbx
0x00000000004011f2 <+254>:   sub    $0x1,%ebp
0x00000000004011f5 <+257>:   jne    0x4011df <phase_6+235>
0x00000000004011f7 <+259>:   add    $0x50,%rsp
0x00000000004011fb <+263>:   pop    %rbx
0x00000000004011fc <+264>:   pop    %rbp
0x00000000004011fd <+265>:   pop    %r12
0x00000000004011ff <+267>:   pop    %r13
0x0000000000401201 <+269>:   pop    %r14
0x0000000000401203 <+271>:   retq 
```

```C
void phase_6(char *input)
{
    strcut{
        int i[6];
        long l[6];
    }data;
    read_six_numbers(input, data.i);
    for(int j=0;j<6;j++)
    {
        if(data.i[j]<=6){
            for(int i=1;i<=5;i++) {
                if(data.i[i]==data.i[0]){
                    explode_bomb();
                }
            }
        }else{
            explode_bomb();
        }
    }
    for(int i=0;i<6;i++)
    {
        data.i[i]=7-data.i[i];
    }
    for(int i=0;i<6;i++)
    {
        data.l[i]=0x6032d0;
    }
    int i=0;
    for(int i=0, j=1;j<6;i=data.l[j++]){
        data.l[i+1]=data.l[j];
    }
}
```